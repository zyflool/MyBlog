---
title: Android 基本的屏幕适配
date: 2020-05-02 16:20:31
tags: 
	- Android
	- 屏幕适配
categories: 学习
---

#### 引入

由于Android系统的开放性，任何用户、开发者、OEM厂商、运营商都可以对Android进行定制，修改成他们想要的样子。

下面这张图片所显示的内容足以充分说明Android系统碎片化问题的严重性，图片中的每一个矩形都代表着一种Android设备。

![屏幕碎片化.png](https://i.loli.net/2020/05/02/fh8sLpUrEtceA2w.png)

而随着支持Android系统的设备(手机、平板、电视、手表)的增多，设备碎片化、品牌碎片化、系统碎片化、传感器碎片化和屏幕碎片化的程度也在不断地加深。而我们今天要探讨的，则是对我们开发影响比较大的——屏幕的碎片化。屏幕尺寸这么多，为了让我们开发的程序能够比较美观的显示在不同尺寸、分辨率、像素密度的设备上，那就要在开发的过程中进行处理。

<!--more-->

#### 一些概念

##### 像素(px)
就是我们通常所说的像素，我们如果把图片放大数倍，会发现这些连续色调其实是由许多色彩相近的小方点所组成，这些小方点就是构成图片的最小单位“像素”(Pixel)。简而言之，像素就是手机屏幕的最小构成单元。

单位是px(pixel)，1px=1像素点，一般情况下UI设计师的设计图会以px作为统一的计量单位。

##### 分辨率

手机在横向、纵向上的像素点数总和 一般描述成宽 * 高 ，即横向像素点个数 * 纵向像素点个数(如1080x1920)，单位也是px(pixel)。

##### 屏幕尺寸(in)

手机对角线的物理尺寸，单位是英寸(inch)，一英寸大约2.54cm，常见的手机尺寸有4.7寸、5寸、5.5寸、6寸等。

##### 屏幕像素密度(dpi)

每英寸的像素点数。 例如每英寸内有160个像素点，则其像素密度就为160dpi。单位是dpi(dots per inch)

- 计算公式： 像素密度 = 像素 / 尺寸 (dpi = px / in)
- 标准屏幕像素密度(mdpi)： 每英寸长度上还有160个像素点(160dpi)，即称为标准屏幕像素密度(mdpi)。

| 密度类型             | 代表的分辨率（px） | 屏幕像素密度（dpi） |
| -------------------- | ------------------ | ------------------- |
| 低密度（ldpi）       | 240 x 320          | 120                 |
| 中密度（mdpi）       | 320 x 480          | 160                 |
| 高密度（hdpi）       | 480 x 800          | 240                 |
| 超高密度（xhdpi）    | 720 x 1280         | 320                 |
| 超超高密度（xxhdpi） | 1080 x 1920        | 480                 |

##### 屏幕尺寸、分辨率、像素密度三者关系

一部手机的分辨率是宽x高，屏幕大小是以寸为单位，三者的关系是：

![屏幕分辨率、尺寸、像素密度的关系.png](https://i.loli.net/2020/05/02/ZjHL1UAgKwynDzk.png)

##### 密度无关像素(density-independent pixel,缩写为dp或dip)

这个概念与终端上的实际物理像素点无关，单位是dp，可以保证在不同屏幕像素密度的设备上显示相同的效果，是安卓特有的长度单位。

假如同样都是画一条长度是屏幕一半的线，如果使用px作为计量单位，那么在480x800分辨率手机上设置应为240px；在320x480的手机上应设置为160px，二者设置就不同了；如果使用dp为单位，在这两种分辨率下，160dp都显示为屏幕一半的长度。

dp与px的转换：1dp = (dpi / 160 ) * 1px;

| 密度类型             | 代表的分辨率（px） | 屏幕密度（dpi） | 换算         |
| -------------------- | ------------------ | --------------- | ------------ |
| 低密度（ldpi）       | 240 x 320          | 120             | 1dp = 0.75px |
| 中密度（mdpi）       | 320 x 480          | 160             | 1dp=1px      |
| 高密度（hdpi）       | 480 x 800          | 240             | 1dp=1.5px    |
| 超高密度（xhdpi）    | 720 x 1280         | 320             | 1dp=2px      |
| 超超高密度（xxhdpi） | 1080 x 1920        | 480             | 1dp=3px      |

##### 独立比例像素(scale-independent pixel,缩写为sp或sip)

单位是sp，字体大小专用单位 Android开发时用此单位设置文字大小，可根据字体大小首选项进行缩放； 推荐使用12sp、14sp、18sp、22sp作为字体大小，不推荐使用奇数和小数，容易造成精度丢失，12sp以下字体太小。

##### sp 与 dp 的区别

dp只跟屏幕的像素密度有关；

sp和dp很类似但唯一的区别是，Android系统允许用户自定义文字尺寸大小(小、正常、大、超大等等)，当文字尺寸是“正常”时1sp=1dp=0.00625英寸，而当文字尺寸是“大”或“超大”时，1sp>1dp=0.00625英寸。类似我们在windows里调整字体尺寸以后的效果——窗口大小不变，只有文字大小改变。

#### 基本的屏幕适配策略

##### 支持不同的屏幕尺寸

+ 要创建适用于不同屏幕尺寸的自适应布局，最佳做法就是将 ConstraintLayout用作界面中的基本布局。使用 ConstraintLayout可以根据布局中视图之间的空间关系来指定每个视图的位置和大小。通过这种方式，当屏幕尺寸改变时，所有视图都可以一起移动和拉伸。

+ 尽量使用“wrap_content”、“match_parent”或者利用约束、layout_weight来协调组件的大小，避免使用硬编码的布局尺寸。

+ 还可以使用各种限定符创建备用布局，使得程序在不同的配置下显示不同的布局：

  + 最小宽度限定符 sw\<N>dp (layout-w320dp/main_activity.xml)
  + 屏幕方向限定符 port、land（layout-land/main_activity.xmll）
  + 可用宽高限定符 w\<N>dp、h\<N>dp (layout-h1024dp/main_activity.xml)
  + ......

+ 创建可拉伸的九宫格位图。如果在改变尺寸的视图中将位图用作背景，当视图根据屏幕尺寸或视图中的内容增大或缩小时，Android 会缩放您的图片。这通常会导致明显的模糊或其他缩放失真。解决方案是使用九宫格位图，这种特殊格式的 PNG 文件会指示哪些区域可以拉伸，哪些区域不可以拉伸。

  九宫格位图基本上是一种标准的 PNG 文件，只不过带有额外的 1 像素边框，指示应拉伸哪些像素（并且带有 `.9.png` 扩展名，而不只是 `.png`）。如下图中所示，左边缘和上边缘的黑线之间的交点是可以拉伸的位图区域。

  ![ninepatch_raw.png](https://i.loli.net/2020/05/03/YRdy6hLeak2itgb.png)

##### 支持不同的像素密度

+ 在设置布局中的各种大小时，使用dp指定长度大小，使用sp指定字体大小

  + 当我们需要根据配置将dp单位转换为像素单位时，可以使用` getResources().getDisplayMetrics().density`来获得`DisplayMetrics.density`这个常量，density = dpi / 160 

  + 可以使用 `ViewConfiguration` 类来获取 Android 系统常用的距离、速度和时间。例如，可通过 `getScaledTouchSlop()` 来获取框架用作滚动阈值的距离（以像素为单位）：

    ```java
private static final int GESTURE_THRESHOLD_DP = ViewConfiguration.get(myContext).getScaledTouchSlop();
    ```

+ 提供备用位图。针对不同的密度创建备用可绘制位图资源：drawable_mdpi、drawable_ldpi、drawable_hdpi、drawable_xhdpi、drawable_xxhdpi、drawable_xxxhdpi，应用图标也应当按照不同的像素密度放入不同的mipmap文件夹中。

  + 系统会根据屏幕的 dpi 选择适当的位图，但是如果没有为某个密度提供特定于密度的资源，那么系统会选取下一个最佳匹配项并对其进行缩放以适合屏幕。所以我们可以根据常用的像素密度大小提供一种像素密度大小的位图，以节省安装包的大小

+ 除了创建多个特定于密度的图片版本之外，另一种方法是仅创建一个矢量图形。在借助矢量图形创建图片时，使用 XML 定义路径和颜色，而不是使用像素位图。因此，矢量图形可以缩放到任何尺寸而不会出现缩放失真，不过它们通常最适合图标等插图，而不太适合照片。

##### 其他

+ 对于ImageView等图片容器，可以使用ScaleType来确定图片等填充效果：
 ![ScaleType.jpeg](https://i.loli.net/2020/05/03/RkLyi35DgOJa17V.jpg)

#### [今日头条适配方案](https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA)

##### 原理

一般我们设计图都是以固定的尺寸来设计的。比如以分辨率1920px * 1080px来设计，以density为3来标注，也就是屏幕其实是640dp * 360dp。如果我们想在所有设备上显示完全一致，其实是不现实的，因为屏幕高宽比不是固定的，16:9、4:3甚至其他宽高比层出不穷，宽高比不同，显示完全一致就不可能了。但是通常下，我们只需要以宽或高一个维度去适配，比如列表是上下滑动的，只需要保证在所有设备中宽的维度上显示一致即可，再比如一个不支持上下滑动的页面，那么需要保证在高这个维度上都显示一致，尤其不能存在某些设备上显示不全的情况。同时考虑到现在基本都是以dp为单位去做的适配，如果新的方案不支持dp，那么迁移成本也非常高。

因此，总结下大致需求如下：

1. 支持以宽或者高一个维度去适配，保持该维度上和设计图一致；
2. 支持dp和sp单位，控制迁移成本到最小。

这时候就需要有一个概念：**density**

**density** 的意思就是 **1 dp** 占当前设备多少像素，为什么要算出 **density**，这和屏幕适配有什么关系呢？

```java
public static float applyDimension(int unit, float value, DisplayMetrics metrics) {
  switch (unit) {
    case COMPLEX_UNIT_PX:
      return value;
    case COMPLEX_UNIT_DIP:
      return value * metrics.density;
    case COMPLEX_UNIT_SP:
      return value * metrics.scaledDensity;
    case COMPLEX_UNIT_PT:
      return value * metrics.xdpi * (1.0f/72);
    case COMPLEX_UNIT_IN:
      return value * metrics.xdpi;
    case COMPLEX_UNIT_MM:
      return value * metrics.xdpi * (1.0f/25.4f);
  }
  return 0;
}
```

无论你在布局文件中填写的是什么单位，最后都会被转化为 **px**，系统就是通过上面的方法，将你在项目中任何地方填写的单位都转换为 **px** 的。所以我们常用的 **px** 转 **dp** 的公式 **dp = px / density**，就是根据上面的方法得来的，**density** 在公式的运算中扮演着至关重要的一步

可以看出，如果设计图宽为360dp，想要保证在所有设备计算得出的px值都正好是屏幕宽度的话，我们只能修改 density 的值，来保证任何情况下我们的屏幕宽度的dp值都为360dp，这样我们就可以在布局中设置和设计图一样大小的宽高dp值并且保证在各种尺寸的屏幕下显示的比例都是一致的。

所以今日头条屏幕适配方案的核心就是，根据

**当前设备屏幕总宽度（单位为像素）/ 设计图总宽度（单位为 dp) = density**

计算出的density值替代系统的density，进而完成对于屏幕总宽度dp值的改变。

这个公式就是把上面公式中的 **屏幕的总 dp 宽度** 换成 **设计图总宽度**，原理都是一样的，只要 **density** 根据不同的设备进行实时计算并作出改变，就能保证 **设计图总宽度** 不变，也就完成了适配。

##### 缺点

只需要修改一次 **density**，项目中的所有地方都会自动适配，这个看似解放了双手，减少了很多操作，但是实际上反应了一个缺点，那就是只能一刀切的将整个项目进行适配，但适配范围是不可控的。这样本来是很好的，但是应用到这个方案是就不好了，这个方案依赖于设计图尺寸，但是项目中的系统控件、三方库控件、等非我们项目自身设计的控件，它们的设计图尺寸并不会和我们项目自身的设计图尺寸一样。

当这个适配方案不分类型，将所有控件都强行使用我们项目自身的设计图尺寸进行适配时，这时就会出现问题，**当某个系统控件或三方库控件的设计图尺寸和和我们项目自身的设计图尺寸差距非常大时，这个问题就越严重**。

还有一些其他潜在的问题，可以深入探讨一下https://github.com/JessYanCoding/AndroidAutoSize/issues/13

#### smallest width限定符适配方案

##### 宽高限定符适配

宽高限定符适配，简单说，就是穷举市面上所有的Android手机的宽高像素值。

设定一个基准的分辨率，其他分辨率都根据这个基准分辨率来计算，在不同的尺寸文件夹内部，根据该尺寸编写对应的dimens文件。

<img src="https://i.loli.net/2020/05/03/b2UBXwGAHKVW9ei.png" alt="宽高限定符.png" style="zoom:80%;" />

比如你的设计图是1280x720px的，所以我们可以设置这个分辨率为基准分辨率

- 宽度为720，将任何分辨率的宽度整分为720份，取值为x1-x7200
- 高度为1280，将任何分辨率的高度整分为1280份，取值为y1-y1280

那么对于1920*1080的分辨率的dimens文件来说，

x1=(1080/720)*1=1.5px

x2=(1080/720)*2=3px

...

![宽高限定符1.png](https://i.loli.net/2020/05/03/JrYgZCR8etf1IFn.png)

![宽高限定符2.png](https://i.loli.net/2020/05/03/eU7RwDPAWNvpcoS.png)

这个时候我们就可以按照设计稿上的尺寸填写相对应的dimens引用了,而当APP运行在不同分辨率的手机中时，这些系统会根据这些dimens引用去该分辨率的文件夹下面寻找对应的值。这样基本解决了我们的适配问题，而且极大的提升了我们UI开发的效率，

但是这个方案有一个致命的缺陷，那就是需要精准命中才能适配，比如1920x1080的手机就一定要找到1920x1080的限定符，否则就只能用统一的默认的dimens文件了。而使用默认的尺寸的话，UI就很可能变形，简单说，就是容错机制很差。

##### 原理

smallestWidth适配，或者叫sw限定符适配。指的是Android会识别**屏幕可用高度和宽度的最小尺寸**的dp值（其实就是手机的宽度值），然后根据识别到的结果去资源文件中寻找对应限定符的文件夹下的资源文件。

这种机制和前面的宽高限定符适配原理上是一样的，都是系统通过特定的规则来选择对应的文件。

举个例子，比如屏幕的dpi是480，横向像素是1080px，根据px=dp(dpi/160)，横向的dp值是1080/(480/160)，也就是360dp，系统就会去寻找是否存在value-sw360dp的文件夹以及对应的资源文件。

![sw限定符适配.png](https://i.loli.net/2020/05/03/8A9YW2uLfol6Fky.png)

smallestWidth限定符适配和宽高限定符适配最大的区别在于，前者有很好的容错机制，如果没有value-sw360dp文件夹，系统会向下寻找，比如离360dp最近的只有value-sw350dp，那么Android就会选择value-sw350dp文件夹下面的资源文件。这个特性就完美的解决了上文提到的宽高限定符的容错问题。

根据固定的放缩比例，我们基本可以按照UI设计的尺寸不假思索的填写对应的dimens引用。 我们还有以375个像素宽度的设计稿为例，在values-sw360dp文件夹下的diemns文件应该怎么编写呢？这个文件夹下，意味着手机的最小宽度的dp值是360，我们把360dp等分成375等份，每一个设计稿中的像素，大概代表smallestWidth值为360dp的手机中的0.96dp，那么接下来的事情就很简单了，假如设计稿上出现了一个10px*10px的ImageView,那么，我们就可以不假思索的在layout文件中写下对应的尺寸。

<img src="https://i.loli.net/2020/05/03/J2xWkO3TiMHubF1.png" alt="1.png" style="zoom: 50%;" />

而这种diemns引用，在不同的values-sw\<N>dp文件夹下的数值是不同的，比如values-sw360dp和values-sw400dp,

<img src="https://i.loli.net/2020/05/03/fks2Z3Cg4LrXBcp.png" alt="1" style="zoom: 50%;" />

<img src="https://i.loli.net/2020/05/03/gO2p8UtLHvbJPTA.png" alt="2.png" style="zoom: 50%;" />

当系统识别到手机的smallestWidth值时，就会自动去寻找和目标数据最近的资源文件的尺寸。

其次，从稳定性上，它也优于上述方案。原生的dp适配可能会碰到有些特别的手机需要单独适配，但是在smallestWidth适配中，通过计算的smallestWidth的值是411，我们只需要生成一个values-sw411dp(或者取整生成values-sw410dp也没问题)就能解决问题。

smallestWidth的适配机制由系统保证，我们只需要针对这套规则生成对应的资源文件即可，不会出现什么难以解决的问题，也根本不会影响我们的业务逻辑代码，而且只要我们生成的资源文件分布合理，即使对应的smallestWidth值没有找到完全对应的资源文件，它也能向下兼容，寻找最接近的资源文件。

##### 缺点

+ smallestWidth适配方案是在Android 3.2 以后引入的，Google的本意是用它来适配平板的布局文件（但是实际上显然用于diemns适配的效果更好），不过目前所有的项目应该最低支持版本应该都是4.0了，所以，这问题其实也不重要了。

+ 多个dimens文件可能导致apk变大，这是事实，根据生成的dimens文件的覆盖范围和尺寸范围，apk可能会增大300kb-800kb左右。

#### 其他

https://blankj.com/2018/12/18/android-adapt-screen-killer/

虚拟导航栏的适配https://juejin.im/post/5bb5c4e75188255c72285b54#heading-3

Google还有一些关于刘海屏的适配策略

#### 引用

+ Google官方屏幕适配文档
+ https://blog.csdn.net/zhaokaiqiang1992/article/details/45419023
+ https://juejin.im/post/5ae32bac518825671a638405#heading-1
+ https://juejin.im/post/5ae9cc3a5188253dc612842b#heading-1
+ http://jessyan.me/autosize-introduce/
+ http://jessyan.me/smallestwidth-introduce/
+ http://jessyan.me/autosize-publish/