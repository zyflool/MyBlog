---
title: 动态规划算法简述
date: 2020-06-17 15:20:05
tags:
	- 算法
	- 动态规划
categories: 学习
---
### 动态规划的概念

动态规划是解决多阶段决策过程最优化问题的一种方法，它通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

### 基本思想

动态规划和分治方法相似，都是通过组合子问题的解来求解原问题。

分治方法将问题划分为互不相交的子问题，再将它们的解组合起来，求出原问题的解。

而动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子问题。所以在这种情况下，采用分治算法会做很多不必要的工作，会反复求解那些公共子问题，与此相反，动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。

通常被用来求解最优化问题。

### 钢条切割问题

![钢条切割问题](https://i.loli.net/2020/06/20/gh2HMnNqt1jVeDJ.png)

| 长度 | 价格 |
| ---- | :--- |
| 1    | 1    |
| 2    | 5    |
| 3    | 8    |
| 4    | 9    |
| 5    | 10   |
| 6    | 17   |
| 7    | 17   |
| 8    | 20   |
| 9    | 24   |
|      | 30   |

考虑n = 4的情况(考虑切割的先后顺序)：

![4英寸钢条的8种切割方案](https://i.loli.net/2020/06/20/6oua3UQLICvZzcy.png)

综合所有情况，n=4情况下的最优解是将一段长度为4英寸的钢条切割为两段各长2英寸的钢条，产生5+5=10的收益。

长度为n英寸的钢条共有2^(n-1)种不同的切割方案，因为在距离钢条坐断i英寸的地方，总是可以选择切割或者不切割。

如果一个最优解将钢条切割为k段，那么这个最优切割方案

<img src="https://i.loli.net/2020/06/20/n9DEUP8twRJNeo1.png" alt="" style="zoom:50%;" />

此时的最大收益即为

<img src="https://i.loli.net/2020/06/20/pRdzTfmHAuVG5oc.png" style="zoom:50%;" />

所以对于r_n，我们可以用比n更短的钢条的最优切割收益来描述它：

<img src="https://i.loli.net/2020/06/20/d6x3iaXz5r87n1T.png" style="zoom:50%;" />

第一个参数p_n对应不切割，后续的参数分别对应：首先切割成i和n-i的两段，接着求这两段段最优切割收益r_i和r_(n-i)。

接着可以将上述公式利用递归求解进行简化：我们将钢条从左边切割下长度为 i 的一段，然后只对右边剩下的长度为 n-i 的一段继续进行切割（递归求解），这样上面的公式就被简化成了

<img src="https://i.loli.net/2020/06/20/WgI8ib2HOxPvpwj.png" style="zoom:50%;" />

此时，原问题的最优解就只包含一个相关子问题（右端剩余部分）的解，而不是两个。

#### 递归求解

```java
public int cut_rod(int p[], int n) {
  if ( n == 0 )
    return 0;
  int q = Integer.MIN_VALUE;
  for ( int i = 1 ; i <= n ; i++ ) {
    q = Math.max(q, p[i]+cut_rod(p, n-i));
  }
  return q;
}
```

#### 使用动态规划方法求解

朴素递归算法的效率很低，是因为它反复求解相同的子问题。因此，动态规划方法仔细安排求解顺序，对每个子问题只求解一次， 并将结果保存下来。如果随后再次需要此子问题的解，只需查找保存的结果，而不必重新计算。因此，动态规划方法是付出额外的内存空间来节省计算时间。

1. 带备忘的自顶向下法（记忆化搜索）。按自然的递归形式编写过程，但过程会保存每个子问题的解。当需要一个子问题的解时，过程首先检查是否已经保存过此解。如果是，则直接返回保存的值，从而节省了计算时间；否则按通常方式计算出这个子问题。

```java
public int memoized_cut_rod(int[] p, int n) {
  int[] r = new int[n+1];
  for ( int i = 1 ; i <= n i++ )
    r[i] = Integer.MIN_VALUE;
  return memorized_cut_rod_aux(p,n,r);
}
public int memoized_cut_rod_aux(int[] p, int n, int[] r) {
  int q;
  if ( r[n] >= 0 )
    return r[n];
  if ( n == 0 )
    q = 0;
  else {
    q = Integer.MIN_VALUE;
    for ( int i = 1 ; i<=n ; i++ ) {
      q = Math.max(q, p[i]+memoized_cut_rod_aux(p, n-i, r));
    }
  }
}
```

2. 自底向上法。这种方法一般需要恰当定义子问题“规模”的概念，使得任何子问题的求解都只依赖于“更小的”子问题的求解。因为他我们可以将子问题按规模排序，按由小至大的顺序进行求解。当求解某个子问题时，它所依赖的那些更小的子问题都已经求解完毕，结果已经保存。每个子问题只需求解一次，当我们求解它时，它的所有前提子问题都已经求解完成。

```java
public int bottom_up_cut_rod(int[] p, int n) {
  int[] r = new int[n+1];
  r[0] = 0;
  for ( int j = 1 ; j <= n ; j++ ) {
    int q = Integer.MIN_VALUE;
    for ( int i = 1 ; i <=j ; i++ ) {
      q = Math.max(q, p[i]+r[j-i]);
    }
    r[j] = q;
  }
  return r[n];
}
```

### 相关概念

#### 最优子结构

如果一个问题的最优解包含其子问题的最优解，就称此问题具有最优子结构性质。因此某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个好线索。是用动态规划方法时，我们用子结构的最优解来构造原问题的最优解。

同一个问题的一个子问题的解不应当影响另一个子问题的解。

#### 重叠子问题

如果递归算法反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质。

### 动态规划问题具有的基本特征

1. 问题具有多阶段决策的特征。阶段可以按时间划分，也可以按空间划分，或者按流动的状态划分。
2. 每一阶段都有相应的“状态”与之对应。
3. 每一阶段都面临一个决策，选择不同的决策将会导致下一阶段不同的状态，同时，不同的决策将会导致这一阶段不同的目标函数值。
4. 每一阶段的最优解问题可以递归地归结为下一阶段各个可能状态的最优解问题，各子问题与原问题具有完全相同的结构。能否构造这样的递推归结，是解决动态规划问题的关键。
5. 最优化原理(最优子结构性质)：不论过去状态和决策如何，对当前的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。
6. 状态具有**无后效性**，当某阶段状态确定后，此阶段以后过程的发展不受此阶段以前各阶段状态的影响。

### 动态规划的基本步骤

1. 刻画一个最优解的结构特征。
2. 递归地定义最优解的值。
3. 计算最优解的值，采用自底向上或者自顶向下。
4. 利用计算出的信息构造一个最优解。

### 最长公共子序列LCS

给定两个序列X=\<x_1, x_2, ... x_m\> 和Y=\<y_1, y_2, ... , y_n\>，求X和Y长度最长的公共子序列。

示例：

```
输入：X = "abcde", Y = "ace" 
输出："ace"
```

#### 步骤一：刻画最长公共子序列的特征

子问题的自然分类对应两个输入序列的“前缀”对（一个序列的第i个前缀为序列的前i个字符组成的序列）。

根据最长公共子序列的概念可以得到下面的定理：

<img src="https://s1.ax1x.com/2020/06/20/NlWJh9.png" style="zoom:50%;" />

#### 步骤二：一个递归解

在求LCS的时候，我们需要求解一个或者两个子问题：

如果 x_m = y_n，我们应该求解X\_(m-1)和Y\_(n-1)的一个LCS，再将x_m追加道这个LCS的末尾，这样就得到了X和Y的一个LCS；

如果 x_m != y_n ，我们必须求解两个子问题：求 X\_(m-1) 和 Y 的一个LCS与 X 和 Y\_(n-1) 的一个LCS，两个LCS较长的即为 X 和 Y 的一个LCS。

定义 c\[i\]\[j\] 表示 Xi 和 Yj 的LCS的长度， 如果 i=0 或者 j=0 ，即一个序列的长度为0，那么LCS的长度也就为0。根据问题的最优子结构性质，得到下面的公式：

<img src="https://s1.ax1x.com/2020/06/20/NlfmUe.png" style="zoom:50%;" />

#### 步骤三：计算LCS的长度

在计算过程中，维护一个表b\[m\]\[n\]，帮助构造最优解，b\[i\]\[j\] 指向的表项对应计算 c\[i\]\[j\] 时所选择的子问题最优解。

```java
public void lcs_length(String X, String Y) {
  int m = X.length();
  int n = Y.length();
  int b[][] = new int[m+1][n+1];
  //0----LCS加入当前字符, 
  //1----当前LCS从[i-1,j]转移
  //-1----当前LCS从[i,j-1]转移
  int c[][] = new int[m+1][n+1];
  for ( int i = 1 ; i <= m ; i++ ) {
    for ( int j = 1 ; j <= n ; j++ ) {
      if ( X.charAt(i-1) == Y.charAt(j-1) ) {
        c[i][j] = c[i-1][j-1]+1;
        b[i][j] = 0;
      } else if ( c[i-1][j] >= c[i][j-1] ) {
        c[i][j] = c[i-1][j];
        b[i][j] = 1;
      } else {
        c[i][j] = c[i][j-1];
        b[i][j] = -1;
      }
    }
  }
  //此时c[m][n]的值即为两个序列的最长公共子序列长度
}
```

#### 步骤四：构造LCS

```java
public void print_lcs(int[][] b, int i, int j) {
  if ( i == 0 || j == 0 ) 
    return ;
  if ( b[i][j] == 0 ) {
    print_lcs(b, X, i-1, j-1);
    System.out.print(X.charAt(i-1));
  } else if ( b[i][j] ==  1) {
    print_lcs(b, X, i-1, j);
  } else 
    print_lcs(b, X, i, j_1);
}
```



引用：《算法导论》